;; Variable declarations

(declare-const x1 Real)
(declare-const x2 Real)

(declare-const w1_1_1 Real)  ; w^(1)_1,1
(declare-const w1_2_1 Real)  ; w^(1)_2,1
(declare-const b1_1   Real)  ; b^(1)_1

(declare-const w1_1_2 Real)  ; w^(1)_1,2
(declare-const w1_2_2 Real)  ; w^(1)_2,2
(declare-const b1_2   Real)  ; b^(1)_2

(declare-const w2_1   Real)  ; w^(2)_1
(declare-const w2_2   Real)  ; w^(2)_2
(declare-const b2     Real)  ; b^(2)

(declare-const g1_1   Real)  ; g^(1)_1
(declare-const g1_2   Real)  ; g^(1)_1
(declare-const g      Real)  ; g

(declare-const f1_1 Real)    ; f^(1)_1
(declare-const f1_2 Real)    ; f^(1)_2
(declare-const f2 Real)      ; f^(2)
(declare-const f_xor Real)   ; f_xor

(declare-const threshold Real)   ; threshold

;; A xor model

(assert (= w1_1_1  3.4243))
(assert (= w1_2_1  3.4299))
(assert (= b1_1   -5.3119))

(assert (= w1_1_2  4.4863))
(assert (= w1_2_2  4.4830))
(assert (= b1_2   -1.7982))

(assert (= w2_1   -7.1722))
(assert (= w2_2    6.7997))
(assert (= b2     -3.0611))

(assert (= threshold 0.1))

;; The xor neural network

(assert (= g1_1 (+ (+ (* x1 w1_1_1) (* x2 w1_2_1)) b1_1)))
(assert (= g1_2 (+ (+ (* x1 w1_1_2) (* x2 w1_2_2)) b1_2)))

(assert (=> (<= g1_1 (- 1))                  (and (< 0 f1_1)    (<= f1_1 0.26))))
(assert (=> (and (< (- 1) g1_1) (<= g1_1 0)) (and (< 0.26 f1_1) (<= f1_1 0.5))))
(assert (=> (and (< 0 g1_1) (<= g1_1 1))  (and (< 0.5 f1_1)  (<= f1_1 0.73))))
(assert (=> (> g1_1 1)                    (and (< 0.73 f1_1) (< f1_1 1))))

(assert (=> (<= g1_2 (- 1))                  (and (< 0 f1_2)    (<= f1_2 0.26))))
(assert (=> (and (< (- 1) g1_2) (<= g1_2 0)) (and (< 0.26 f1_2) (<= f1_2 0.5))))
(assert (=> (and (< 0 g1_2) (<= g1_2 1))  (and (< 0.5 f1_2)  (<= f1_2 0.73))))
(assert (=> (> g1_2 1)                    (and (< 0.73 f1_2) (< f1_2 1))))

(assert (= g    (+ (+ (* f1_1 w2_1) (* f1_2 w2_2)) b2)))

(assert (=> (<= g (- 1))               (and (< 0 f2)    (<= f2 0.26))))
(assert (=> (and (< (- 1) g) (<= g 0)) (and (< 0.26 f2) (<= f2 0.5)))) 
(assert (=> (and (< 0 g) (<= g 1))  (and (< 0.5 f2)  (<= f2 0.73))))
(assert (=> (> g 1)                 (and (< 0.73 f2) (< f2 1))))

(assert (= f_xor f2))

;; ;; A robustness property

(assert
  (not
     (and (=> (and (<= (- 0 threshold) (- x1 x2)) (<= (- x1 x2) threshold)) (< f_xor 0.5 ) )
          (=> (or  (<  (- x1 x2) (- 0 threshold)) (>  (- x1 x2) threshold)) (> f_xor 0.5 ) )))
	 )

;; ;; Solving

;; $ z3 ./xor_nn.smtlib
;; unsat

(check-sat) 
;; (get-model)
(get-value (x1 x2))
(get-value (f_xor))
(get-value (g))
(get-value (f1_1))
(get-value (f1_2))
(get-value (g1_1))
(get-value (g1_2))

;; -------------------------------------------
;; nodes    Encoding(Z3)  XOR NN
;; -------------------------------------------
;; x1       0.125         0.125
;; x2       0.125         0.125

;; g1_1    -4.455125      -4.455125
;; g1_2    -0.6770375     -0.6770375

;; f1_1     0.125         0.011485419854808205
;; f1_2     0.4375        0.33692282230455134

;; g       -0.98275625   -0.852501613458398

;; f2       0.5           0.2989083504533866
;; --------------------------------------------

;; -0.98275625로 -1과 0 구간 사이이고,
;; sigmoid approximation에서 0.26부터 0.5를 선택할 수 있다.
;; 실제 해는 0.2989... 인데, Z3가 선택한 숫자는 0.5였다.
;; 즉, sigmoid를 너무 뭉뚱그려서 근사하다보니(coarse apporiximation) 검증할 수 없었다.

;; sigmoid를 얼마나 촘촘하게 나누면 xor 모델을 검증할 수 있을까?
;; 주어진 xor 모델에 대해서 그러한 촘촘함은 존재하는 것인가,
;; 아니면 아무리 촘촘하게 해도 xor 모델을 검증할 수 없는 것인가?

;; [1st trial] 

;; ((x1 (/ 1.0 8.0)) 
;;  (x2 (/ 1.0 8.0)))

;; ((g1_1 (- (/ 35641.0 8000.0))))
;; ((g1_2 (- (/ 54163.0 80000.0))))

;; ((f1_1 (/ 1.0 8.0)))
;; ((f1_2 (/ 7.0 16.0)))

;; ((g (- (/ 157241.0 160000.0))))

;; ((f_xor (/ 1.0 2.0)))

;; ghci> f_xor (1.0/8.0) (1.0/8.0)
;; 0.2989083504533866
;; ghci> f1_1 (1.0/8.0) (1.0/8.0)
;; 1.1485419854808205e-2
;; ghci> f1_2 (1.0/8.0) (1.0/8.0)
;; 0.33692282230455134
;; ghci> 1.0/8.0
;; 0.125
;; ghci> 7.0 / 16.0
;; 0.4375
;; ghci> g1_1 (1.0/8.0) (1.0/8.0)
;; -4.455125
;; ghci> g1_2 (1.0/8.0) (1.0/8.0)
;; -0.6770375
;; ghci> g (f1_1 (1.0/8.0) (1.0/8.0)) (f1_2 (1.0/8.0) (1.0/8.0))
;; -0.852501613458398
;; ghci> - (157241.0 / 160000.0)
;; -0.98275625
;; ghci> -0.98275625 <= -1
;; False
